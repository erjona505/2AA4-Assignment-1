// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package Catan_Part1;

/************************************************************/

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 *
 */
public class GameMap {


    private ArrayList<Tile> tiles;
    private ArrayList<Node> nodes;
    private ArrayList<Edge> edges;

    private Map<Integer, List<Integer>> tilesToNodes;
    private Map<Integer, List<Integer>> nodeToEdges;
    private Map<Integer, List<Integer>> nodeNeighbors;



    public  GameMap() {
        tiles= new ArrayList<Tile>();
        nodes=new ArrayList<Node>();
        edges=new ArrayList<Edge>();

        tilesToNodes= new HashMap<Integer, List<Integer>>();
        nodeToEdges= new HashMap<Integer, List<Integer>>();
        nodeNeighbors= new HashMap<Integer, List<Integer>>();






    }

    /**
     *
     * @param id
     * @return
     */
    public Tile getTile(int id) {
        if (id>=0 && id<tiles.size()){
            return tiles.get(id);
        }
        return null;
    }

    /**
     *
     * @param id
     * @return
     */
    public Node getNode(int id) {

        if (id>=0 && id>nodes.size()){
            return nodes.get(id);
        }
        return null;

    }

    /**
     *
     * @param id
     * @return
     */
    public Edge getEdge(int id) {
        //check if the id does truly exist and that it is not out of bounds
        if (id>=0){
            return edges.get(id);

        }
        return null;
    }

    /// helper method to allow nodes to recognize  who their neighbors are
    private void addNodeNeighbor(int IdNode1, int IdNode2){
        //do nothing if the nodes do not exist
        if (getNode(IdNode1)==null || getNode(IdNode2)==null){
            return;
        }
        //add node 2 as a neighbor for node 1
        if (!nodeNeighbors.get(IdNode1).contains(IdNode2)){
            nodeNeighbors.get(IdNode1).add(IdNode2);
        }
        //other way around
        if (!nodeNeighbors.get(IdNode2).contains(IdNode2)){
            nodeNeighbors.get(IdNode2).add(IdNode1);
        }

    }

    /**
     *
     * @param agent
     * @param edgeId
     * @return
     */
    public boolean isRoad(Agent agent, int edgeId) {
        Edge edge = getEdge(edgeId);

        if (edge != null && edge.isOccupied()) {
            return edge.getRoad().getOwner() == agent;
        }

        return false;
    }

    /**
     *
     * @param agent
     * @param nodeId
     * @return
     */
    public boolean isSettlement(Agent agent, int nodeId) {
        Node node = getNode(nodeId);

        if (node != null && node.isOccupied() && node.getBuilding() instanceof Settlement) {
            return node.getBuilding().getOwner() == agent;
        }

        return false;
    }

    /**
     *
     * @param agent
     * @param nodeId
     * @return
     */
    public boolean isCity(Agent agent, int nodeId) {
        Node node = getNode(nodeId);

        if (node != null && node.isOccupied() && node.getBuilding() instanceof City) {
            return node.getBuilding().getOwner() == agent;
        }

        return false;
    }

    /**
     *
     * @param agent
     * @param edgeId
     */
    public boolean placeRoad(Agent agent, int edgeId) {
        Edge edge = getEdge(edgeId);

        if (edge == null || edge.isOccupied()) {
            return false;
        }

        if (!isConnectedtoAgent(edgeId)) {
            return false;
        }

        edge.setRoad(new Road(agent, edgeId));
        return true;
    }





    /**
     *
     * @param agent
     * @param nodeId
     */
    public boolean placeSettlement(Agent agent, int nodeId, boolean isInitialPlacement) {
        Node node = getNode(nodeId);

        if (node == null || node.isOccupied()) {
            return false;
        }

        if (!isValidSettlementPosition(nodeId)){
              return false;
        }

        if (!isInitialPlacement && !hasAdjacentRoad(agent, nodeId)) {
              return false;
        }

        node.setBuilding(new Settlement(agent, nodeId));
        return true;

    }

    /**
     *
     * @param agent
     * @param nodeId
     */
    private boolean placeCity(Agent agent, int nodeId) {
        Node node = getNode(nodeId);

        if (node == null) {
            return false;
        }

        if (!isSettlement(agent, nodeId)) {
            return false;
        }

        node.setBuilding(new City(agent, nodeId));
        return true;
    }

    /**
     *
     * @param agent
     * @param nodeId
     */
    public boolean upgrade(Agent agent, int nodeId) {
        return placeCity(agent, nodeId);
    }

    public List<Tile> getTiles() {
        return tiles;
    }

    public List<Node> getNodes() {
        return nodes;
    }
    public List<Edge> getEdges() {
        return edges;
    }

    public void distributeResources(int diceRoll) {

        if (diceRoll == 7) {
            return;
        }

        for (Tile tile : tiles) {

            if (tile.getNumberToken() != diceRoll) {
                continue;
            }

            List<Integer> adjacentNodes = tilesToNodes.get(tile.getId());

            for (int nodeId : adjacentNodes) {

                Node node = getNode(nodeId);
                if (node == null || !node.isOccupied()) {
                    continue;
                }

                Building building = node.getBuilding();
                int resourceAmount = building.getResourceAmount();
                Agent owner = building.getOwner();

                owner.getResources.add(tile.getResourceType(), resourceAmount);
            }



        }
    }
}
