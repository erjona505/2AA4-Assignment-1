// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package Catan_Part1;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 *
 */
public class GameMap {


    private ArrayList<Tile> tiles;
    private ArrayList<Node> nodes;
    private ArrayList<Edge> edges;

    private Map<Integer, List<Integer>> tilesToNodes;
    private Map<Integer, List<Integer>> edgeToNodes;
    private Map<Integer, List<Integer>> nodeNeighbors;



    public  GameMap() {
        tiles= new ArrayList<Tile>();
        nodes=new ArrayList<Node>();
        edges=new ArrayList<Edge>();

        tilesToNodes= new HashMap<Integer, List<Integer>>();
        edgeToNodes = new HashMap<Integer, List<Integer>>();
        nodeNeighbors= new HashMap<Integer, List<Integer>>();

    }


    public void initboard(){

        //initialize all nodes, tiles and edges
        initEdge();
        initNode();
        initTiles();
        initMaps();


        //initialize all relationship between nodes, tiles and edges
        initNodeToNode();
        initEdgeToNodes();
        initTilesToNodes();

    }





    /**A list of helper functions to aid with initializing the board and establishing relationship between tiles, nodes and edges* */


    //init the inner lists in every
    ///HELPERS FOR INITIALIZE THE BOARD

    //init all 19 tiles
    private void initTiles(){
        //center Tile (0)
        tiles.add(new Tile(0, ResourceType.WOOD, 10));
        //inner ring (1-6)
        tiles.add(new Tile(1, ResourceType.WHEAT, 11));
        tiles.add(new Tile(2, ResourceType.BRICK, 8));
        tiles.add(new Tile(3, ResourceType.ORE, 3));
        tiles.add(new Tile(4, ResourceType.SHEEP, 11));
        tiles.add(new Tile(5, ResourceType.SHEEP, 5));
        tiles.add(new Tile(6, ResourceType.SHEEP, 12));
        //outer ring (7-18)
        tiles.add(new Tile(7, ResourceType.WHEAT, 3));
        tiles.add(new Tile(8, ResourceType.ORE, 6));
        tiles.add(new Tile(9, ResourceType.WOOD, 4));
        tiles.add(new Tile(10, ResourceType.ORE, 6));
        tiles.add(new Tile(11, ResourceType.WHEAT, 9));
        tiles.add(new Tile(12, ResourceType.WOOD, 5));
        tiles.add(new Tile(13, ResourceType.BRICK, 9));
        tiles.add(new Tile(14, ResourceType.BRICK, 8));
        tiles.add(new Tile(15, ResourceType.WHEAT, 4));
        tiles.add(new Tile(16, ResourceType.DESERT, -1)); // -1 indicated it has no token (empty)
        tiles.add(new Tile(17, ResourceType.WOOD, 2));
        tiles.add(new Tile(18, ResourceType.SHEEP, 10));
    }

//init all 54 nodes
    private void initNode(){
        //create 54 nodes (establish relationship later)
        for (int i=0; i<54; i++){
            nodes.add(new Node(i));
        }
    }
//Init 72 edges
    private void initEdge(){
        //create 72 unique edges
        for (int i=0; i<72; i++){
            edges.add(new Edge(i));
        }
    }

    //init the lists in the hash maps
    //maps just store ids not the full object
    private void initMaps(){
        for (int i=0; i<tiles.size(); i++){
            tilesToNodes.put(i, new ArrayList<Integer>());
        }

        for (int i=0; i<edges.size();i++){
            edgeToNodes.put(i, new ArrayList<Integer>());
        }
        for (int i = 0; i < nodes.size(); i++) {
            nodeNeighbors.put(i, new ArrayList<Integer>());

        }
    }


    //HELPERS for establishing relationship b/m nodes, tiles and edges

    /// helper method to allow nodes to recognize  who their neighbors are
    private void addSingleNodeNeighbor(int nodeId1, int nodeId2){
        //do nothing if the nodes do not exist
        if (getNode(nodeId1)==null || getNode(nodeId2)==null){
            return;
        }
        //add node 2 as a neighbor for node 1
        if (!nodeNeighbors.get(nodeId1).contains(nodeId2)){
            nodeNeighbors.get(nodeId1).add(nodeId2);
        }
        //other way around
        if (!nodeNeighbors.get(nodeId2).contains(nodeId1)){
            nodeNeighbors.get(nodeId2).add(nodeId1);
        }

    }

    //takes in a node, and any number of surrounding nodes to establish a
    //neighbor relationship for all of them
    private void addAllNeighbors(int node, int... neighbors){
        //adds every neighbor node with the original
        for (int n: neighbors){
            addSingleNodeNeighbor(node, n);
        }
    }
    //hard coding node to node relationships
    private void initNodeToNode(){
        //Top Row
        addAllNeighbors(42,41,40);
        addAllNeighbors(44,40,43);
        addAllNeighbors(45,43,47);

        //upper middle row
        addAllNeighbors(41,42,39);
        addAllNeighbors(40,42,44,18);
        addAllNeighbors(43,44,45,21);
        addAllNeighbors(47,45,46);

        //Middle row
        addAllNeighbors(39,41,38);
        addAllNeighbors(18,40,17,16);
        addAllNeighbors(21,43,19,16);
        addAllNeighbors(46,47,48);

        //Center Upper row
        addAllNeighbors(38,39,37);
        addAllNeighbors(17,18,15);
        addAllNeighbors(16,18,21,5);
        addAllNeighbors(19,21,20);
        addAllNeighbors(48,46,49);

        //center row
        addAllNeighbors(37,38,36);
        addAllNeighbors(15,17,14);
        addAllNeighbors(5,16,4,0);
        addAllNeighbors(20,19,22);
        addAllNeighbors(49,48,50);

        //center lower row
        addAllNeighbors(36,37,35);
        addAllNeighbors(14,15,13);
        addAllNeighbors(4,5,2);
        addAllNeighbors(0,5,1);
        addAllNeighbors(22,20,23);
        addAllNeighbors(50,49,51);

        //lower middle row
        addAllNeighbors(35,36,34);
        addAllNeighbors(13,14,12);
        addAllNeighbors(2,4,9);
        addAllNeighbors(1,0,6);
        addAllNeighbors(23,22,52);
        addAllNeighbors(51,50,52);

        //lower row
        addAllNeighbors(34, 35, 33);
        addAllNeighbors(12, 13, 11);
        addAllNeighbors(9, 2, 8);
        addAllNeighbors(6, 1, 7);
        addAllNeighbors(52, 23, 53);

        // Bottom
        addAllNeighbors(33, 34, 32);
        addAllNeighbors(11, 12, 10);
        addAllNeighbors(8, 9, 27);
        addAllNeighbors(7, 6, 24);
        addAllNeighbors(53, 52, 24);

      // Bottom even more
        addAllNeighbors(32, 33, 31);
        addAllNeighbors(10, 11, 29);
        addAllNeighbors(27, 8, 26);
        addAllNeighbors(24, 7, 25);

        // Tips
        addAllNeighbors(31, 32, 30);
        addAllNeighbors(29, 10, 28);
        addAllNeighbors(26, 27, 25);
    }

    //helper methods for a relationship between  every edge and two nodes
    private void addEdgeBetweenNodes(int edge, int node1, int node2){
        if (edges.get(edge)==null || nodes.get(node1)==null || nodes.get(node2)==null){
            return;
        }
        edgeToNodes.get(edge).add(node1);
        edgeToNodes.get(edge).add(node2);

    }

    //hard coding relationship between each edge and its own node
    private void initEdgeToNodes(){
        // (0-9)
        addEdgeBetweenNodes(0, 42, 41);
        addEdgeBetweenNodes(1, 42, 40);
        addEdgeBetweenNodes(2, 41, 39);
        addEdgeBetweenNodes(3, 40, 44);
        addEdgeBetweenNodes(4, 40, 18);
        addEdgeBetweenNodes(5, 44, 43);
        addEdgeBetweenNodes(6, 43, 45);
        addEdgeBetweenNodes(7, 43, 21);
        addEdgeBetweenNodes(8, 45, 47);
        addEdgeBetweenNodes(9, 47, 46);

        // (10-14)
        addEdgeBetweenNodes(10, 39, 38);
        addEdgeBetweenNodes(11, 18, 17);
        addEdgeBetweenNodes(12, 18, 16);
        addEdgeBetweenNodes(13, 21, 19);
        addEdgeBetweenNodes(14, 46, 48);

        //  (15-19)
        addEdgeBetweenNodes(15, 38, 37);
        addEdgeBetweenNodes(16, 17, 15);
        addEdgeBetweenNodes(17, 16, 5);
        addEdgeBetweenNodes(18, 19, 20);
        addEdgeBetweenNodes(19, 48, 49);

        // Center (20-25)
        addEdgeBetweenNodes(20, 37, 36);
        addEdgeBetweenNodes(21, 15, 14);
        addEdgeBetweenNodes(22, 5, 4);
        addEdgeBetweenNodes(23, 5, 0);
        addEdgeBetweenNodes(24, 20, 22);
        addEdgeBetweenNodes(25, 49, 50);

        // Center lower (26-31)
        addEdgeBetweenNodes(26, 36, 35);
        addEdgeBetweenNodes(27, 14, 13);
        addEdgeBetweenNodes(28, 4, 2);
        addEdgeBetweenNodes(29, 0, 1);
        addEdgeBetweenNodes(30, 22, 23);
        addEdgeBetweenNodes(31, 50, 51);

        // Lower middle (32-37)
        addEdgeBetweenNodes(32, 35, 34);
        addEdgeBetweenNodes(33, 13, 12);
        addEdgeBetweenNodes(34, 2, 9);
        addEdgeBetweenNodes(35, 1, 6);
        addEdgeBetweenNodes(36, 23, 52);
        addEdgeBetweenNodes(37, 51, 52);

        // Lower (38-42)
        addEdgeBetweenNodes(38, 34, 33);
        addEdgeBetweenNodes(39, 12, 11);
        addEdgeBetweenNodes(40, 9, 8);
        addEdgeBetweenNodes(41, 6, 7);
        addEdgeBetweenNodes(42, 52, 53);

        // Bottom (43-47)
        addEdgeBetweenNodes(43, 33, 32);
        addEdgeBetweenNodes(44, 11, 10);
        addEdgeBetweenNodes(45, 8, 27);
        addEdgeBetweenNodes(46, 7, 24);
        addEdgeBetweenNodes(47, 53, 24);

        // Bottom-most (48-51)
        addEdgeBetweenNodes(48, 32, 31);
        addEdgeBetweenNodes(49, 10, 29);
        addEdgeBetweenNodes(50, 27, 26);
        addEdgeBetweenNodes(51, 24, 25);

        // Bottom tips (52-54)
        addEdgeBetweenNodes(52, 31, 30);
        addEdgeBetweenNodes(53, 29, 28);
        addEdgeBetweenNodes(54, 26, 25);

        // Remaining edges to complete 72 (55-71)
        addEdgeBetweenNodes(55, 41, 40);
        addEdgeBetweenNodes(56, 44, 18);
        addEdgeBetweenNodes(57, 21, 16);
        addEdgeBetweenNodes(58, 16, 21);
        addEdgeBetweenNodes(59, 17, 18);
        addEdgeBetweenNodes(60, 15, 17);
        addEdgeBetweenNodes(61, 14, 15);
        addEdgeBetweenNodes(62, 13, 14);
        addEdgeBetweenNodes(63, 12, 13);
        addEdgeBetweenNodes(64, 11, 12);
        addEdgeBetweenNodes(65, 10, 11);
        addEdgeBetweenNodes(66, 4, 5);
        addEdgeBetweenNodes(67, 2, 4);
        addEdgeBetweenNodes(68, 9, 2);
        addEdgeBetweenNodes(69, 8, 9);
        addEdgeBetweenNodes(70, 1, 0);
        addEdgeBetweenNodes(71, 6, 1);
    }

    //helper methods for tiles with nodes
    private void addTileToNodes(int tileId, int... nodeIds){
        if (tiles.get(tileId)==null){return ;}

        for (int node: nodeIds){
            if (nodes.get(node) != null){
                tilesToNodes.get(tileId).add(node);
            }
        }
    }

    //hard coding which nodes go with which tiles

    private void initTilesToNodes(){

        addTileToNodes(0, 0, 1, 2, 4, 5, 6);

        // inner ring ( 1-6)
        addTileToNodes(1, 5, 16, 17, 18, 15, 14);  // Top-left inner
        addTileToNodes(2, 16, 21, 19, 20, 22, 23);  // Top-right inner
        addTileToNodes(3, 0, 5, 4, 2, 9, 8);        // Right inner
        addTileToNodes(4, 23, 52, 53, 24, 7, 6);    // Bottom-right inner
        addTileToNodes(5, 1, 6, 7, 24, 25, 26);     // Bottom-left inner
        addTileToNodes(6, 14, 13, 12, 11, 10, 15);  // Left inner

        // Outer ring ( 7-18)
        addTileToNodes(7, 38, 37, 36, 35, 34, 39);  // Far left
        addTileToNodes(8, 17, 18, 40, 42, 41, 39);  // Top-left
        addTileToNodes(9, 18, 21, 43, 44, 40, 18);  // Top
        addTileToNodes(10, 21, 19, 20, 22, 23, 16); // Top-right
        addTileToNodes(11, 46, 47, 45, 43, 21, 48); // Right-top
        addTileToNodes(12, 48, 49, 50, 51, 52, 46); // Far right
        addTileToNodes(13, 52, 23, 22, 20, 19, 53); // Right-bottom
        addTileToNodes(14, 9, 8, 27, 26, 25, 2);    // Bottom-right
        addTileToNodes(15, 27, 8, 7, 24, 25, 26);   // Bottom
        addTileToNodes(16, 24, 7, 6, 1, 0, 25);     // Bottom-left
        addTileToNodes(17, 33, 32, 31, 30, 28, 34); // Far bottom
        addTileToNodes(18, 11, 10, 29, 28, 30, 12);

    }


    //creates and returns a list of all the neigbors of a node
    private List<Integer> getNeighborNodes(int nodeId){
        return nodeNeighbors.getOrDefault(nodeId, new ArrayList<>());
    }

    public boolean isValidSettlementPosition(int nodeId){
        Node targetNode= getNode(nodeId);
        //check if the node does not exist
        if (targetNode==null)
            return false;

        //Check if node is full
        if (targetNode.getBuilding()!=null)
            return false;

        //check that no neigbor of the node is full (has a building etc)
        for (int neighborId: getNeighborNodes(nodeId)){
            //get that specfic node object
            Node neighbor=getNode(neighborId);
            //check if its a valid node and is full
            if (neighbor!= null && !neighbor.isOccupied()){ return true;}
        }




//if it does not violate any rules we return true to indicate that the node is a valid position place
        return true;
    }
//does this agent have atleast one road touching this node
    //if they do then they are allowed to build here
    //id not they cant build there
    public boolean hasAdjacentRoad(Agent agent, int nodeId) {

        //check if the agent does in fact exist
        if (agent == null)
            return false;

        //look at every edge
        for (int edgeId : edgeToNodes.keySet()) {

            //find the  nodes that are associated with this edge
            List<Integer> nodes = edgeToNodes.get(edgeId);

            //check if that edge touches our node
            if (nodes.contains(nodeId)) {
                Edge edge = edges.get(edgeId);
                if (edge == null) continue;

                //if the edge touches our node, it must have a road and that road must belong to this agent
                if (edge.getRoad() != null && agent.equals(edge.getRoad().getOwner())) {
                    return true; //FOUND one adjacent road owned by the agent
                }
                //check if that edge has a road owned by this agent


            }
        }
        return false;
    }


    //helper method returns a list of which edges are touching this node






    //check if the agent has a road, sett, city at either end of the edge
    public boolean isConnectedToAgent(Agent agent, int edgeId){

        //stores both end points of the edge
        List<Integer> endpoints= edgeToNodes.get(edgeId);

        for (int nodeId: endpoints) {
            //check if the nodes have a building (either settlement or city)
            Node node = getNode(nodeId);
            if (node != null && node.isOccupied() && agent.equals(node.getBuilding().getOwner())) {
                return true;
            }
            //check for any road on any other edge at this node
            if (hasAdjacentRoad(agent,nodeId)){
                return true;
            }

        }
        return false;

        //check if the agent has a road on any o
    }







    /**
     *
     * @param id
     * @return
     */
    public Tile getTile(int id) {
        if (id>=0 && id<tiles.size()){
            return tiles.get(id);
        }
        return null;
	}

	/**
	 * 
	 * @param id 
	 * @return node
	 */
	public Node getNode(int id) {

        if (id>=0 && id<nodes.size()){
            return nodes.get(id);
        }
        return null;

    }

	/**
	 * 
	 * @param id 
	 * @return  edge
	 */
	public Edge getEdge(int id) {
        //check if the id does truly exist and that it is not out of bounds
        if (id>=0){
            return edges.get(id);

        }
        return null;
    }





    /**
     *
     * @param agent
     * @param edgeId
     * @return
     */
    public boolean isRoad(Agent agent, int edgeId) {
        Edge edge = getEdge(edgeId);

        if (edge != null && edge.isOccupied()) {
            return edge.getRoad().getOwner() == agent;
        }

        return false;
    }

    /**
     *
     * @param agent
     * @param nodeId
     * @return
     */
    public boolean isSettlement(Agent agent, int nodeId) {
        Node node = getNode(nodeId);

        if (node != null && node.isOccupied() && node.getBuilding() instanceof Settlement) {
            return node.getBuilding().getOwner() == agent;
        }

        return false;
    }

    /**
     *
     * @param agent
     * @param nodeId
     * @return
     */
    public boolean isCity(Agent agent, int nodeId) {
        Node node = getNode(nodeId);

        if (node != null && node.isOccupied() && node.getBuilding() instanceof City) {
            return node.getBuilding().getOwner() == agent;
        }

        return false;
    }

    /**
     *
     * @param agent
     * @param edgeId
     */
    public boolean placeRoad(Agent agent, int edgeId) {
        Edge edge = getEdge(edgeId);

        if (edge == null || edge.isOccupied()) {
            return false;
        }

        if (!isConnectedToAgent(agent, edgeId)) {
            return false;
        }

        edge.setRoad(new Road(agent, edgeId));
        agent.addPoints(edge.getRoad().getPoints());
        return true;
    }





    /**
     *
     * @param agent
     * @param nodeId
     */
    public boolean placeSettlement(Agent agent, int nodeId, boolean isInitialPlacement) {
        Node node = getNode(nodeId);

        if (node == null || node.isOccupied()) {
            return false;
        }

        if (!isValidSettlementPosition(nodeId)){
              return false;
        }

        if (!isInitialPlacement && !hasAdjacentRoad(agent, nodeId)) {
              return false;
        }

        node.setBuilding(new Settlement(agent, nodeId));
        agent.addPoints(node.getBuilding().getPoints());
        return true;

    }

    /**
     *
     * @param agent
     * @param nodeId
     */
    private boolean placeCity(Agent agent, int nodeId) {
        Node node = getNode(nodeId);

        if (node == null) {
            return false;
        }

        if (!isSettlement(agent, nodeId)) {
            return false;
        }

        node.setBuilding(new City(agent, nodeId));
        agent.addPoints(node.getBuilding().getPoints());
        return true;
    }

    /**
     *
     * @param agent
     * @param nodeId
     */
    public boolean upgrade(Agent agent, int nodeId) {
        return placeCity(agent, nodeId);
    }

    public void distributeInitialResources(Agent agent, int settlementNodeId) {

        // loop through all tiles and check if this node touches that tile
        for (Tile tile : tiles) {

            if (tile.getResourceType() == ResourceType.DESERT) {
                continue;
            }

            List<Integer> adjacentNodes = tilesToNodes.get(tile.getId());
            if (adjacentNodes == null) continue;

            if (adjacentNodes.contains(settlementNodeId)) {
                // setup rule = 1 card per adjacent tile
                agent.getResources().add(tile.getResourceType(), 1);
            }
        }
    }


    public void distributeResources(int diceRoll) {

        if (diceRoll == 7) {
            return;
        }

        for (Tile tile : tiles) {

            if (tile.getResourceType() == ResourceType.DESERT) {
                continue;
            }

            if (tile.getNumberToken() != diceRoll) {
                continue;
            }

            List<Integer> adjacentNodes = tilesToNodes.get(tile.getId());

            for (int nodeId : adjacentNodes) {

                Node node = getNode(nodeId);
                if (node == null || !node.isOccupied()) {
                    continue;
                }

                Building building = node.getBuilding();
                int resourceAmount = building.getResourceAmount();
                Agent owner = building.getOwner();

                owner.getResources().add(tile.getResourceType(), resourceAmount);
            }



        }
    }
}
